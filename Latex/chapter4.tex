\chapter{Authenticity Proofs}\label{chap:chap4}

\section*{}
As technology evolves and becomes mainstream so does the amount of generated data and its distribution. And so it becomes crucial to be able to authenticate a piece of information as originating from a known, trusted source. 

In the context of today's web we are accustomed to trust that a certain website or data is originated from the expected source due to the general adoption of the HTTPS protocol. An extension fo the HTTP protocol which creates and encrypted and authenticated channel between the client and the web-server providing the requested information. Then it becomes a matter of whether we trust the source or not, but not doubts are raised as for the channel through which we received it.

Unfortunately, in the context of blockchain, the most used, available and trusted protocols have not direct way of communicating with HTTPS enabled services and therefore obtain authenticated data. Creating a need for a trusted service, which if centralized if fallible unless it can provide an irrefutable proof of its honesty. 

Several authenticity have therefore been developed and, as seen in the state-of-the-art revision, most oracles as a service providers use authenticity proofs to prove their honest behaviour. However, these proofs are not infallible and the details or their implementation are not always transparent or do not provide the disclosed level of trust. In this section, I will deep dive on the most common proofs and discuss their implementation and applicability.


\section{TLSNotary}

TLSNotary is a mechanism for independently audited HTTPS sessions. Allowing clients to provide evidence to a third party auditor that certain web traffic occurred between himself and the server. This mechanism takes leverage of the TLS handshake protocol to create a irrefutable proof as long as the auditor trusts the server's public key by splitting the TLS master key between three parties: the server, the auditee and the auditor.

The algorithm allows an auditor to verify some part of a session by withholding a small part of the secret data used to set up the HTTPS connection while allowing the client to conduct a HTTPS session normally. The auditor never fully possesses, at any time, any of the session keys and therefore cannot decrypt any sensitive information and can only verify that a certain traffic did occurred.

\subsection{How it works}
TLSNotary modifies the TLS handshake protocol on the client side by levering some properties of TLS 1.0 and 1.1. More specifically the pseudorandom function (PRF) used in the TLS 1.0 RFC 2246.

\begin{ceqn}
    \begin{align}
        PRF(secret,label,seed) = PMD5(S1,label+seed) \otimes PSHA-1(S2,label+seed)
    \end{align}
\end{ceqn}

This function compromises two secrets, S1 and S2. The auditor and auditee will independently generate S1 and S2, respectively. 

The auditee applies P\_MD5 to S1, generating 48 bytes:

\begin{ceqn}
    \begin{align}
        H_{1} = H_{1,1} \parallel H_{1,2}
    \end{align}
\end{ceqn}

The auditor applies P\_SHA-1 to S2, generating 48 bytes:

\begin{ceqn}
    \begin{align}
        H_{2} = H_{2,1} \parallel H_{2,2}
    \end{align}
\end{ceqn}


The auditor and auditee then exchange H21 and H12 allowing each other to construct different halves of the master secret, M2 and M1, respectively.

\begin{ceqn}
    \begin{align}
        M_{2} = H_{1,2} \parallel H_{2,2}
    \end{align}
\end{ceqn}

\begin{ceqn}
    \begin{align}
        M_{1} = H_{2,1} \parallel H_{1,1}
    \end{align}
\end{ceqn}

The auditee and auditor calculate X and Y, respectively.

\begin{ceqn}
    \begin{align}
        X = P\_MD5(M_{1})
    \end{align}
\end{ceqn}

\begin{ceqn}
    \begin{align}
        Y = P\_SHA-1(M_{2})
    \end{align}
\end{ceqn}

The auditor sends sufficient bytes from Y to the auditee so that it can compute the necessary encryption keys and client mac key to send the request to the server.

Then the server response is received, but not decrypted, and the network traffic is logged and a hash is of the traffic is computed and set to the auditor as commitment. 

Only then, does the auditor send the remaining bytes of Y to the auditee that allow him to calculate the server mac key and safely execute a normal TLS decryption and authentication step.

These complex sequence of calculations prevent the auditee from creating a fake version of the post-handshake traffic from the server since he did not have in his possession the server mac write secret to decrypt and authenticate the initially requested data.

A more detailed flow and explanation can be consulted in the TLSNotary white-paper \cite{2014TLSnotary-aSessions}.

\subsection{Limitations}
TLSNotary, provides some capabilities to attest TLS connections but comes with several limitation. Firstly, TLSNotary supports only TLS 1.0 or 1.1, the properties mentioned before are not present in TLS 1.2 and 1.3 and former are considered less secure versions of TLS. Secondly, TLSNotary depends on RSA Key exchange, which does not provide forward secrecy. Thirdly, TLSNotary uses MD5 and SHA-1 functions, which are now considered deprecated. Finally and most importantly, TLSNotary requires trusting in a third party in most of its implementations, such as in Oraclize \cite{Oraclize.it2018OraclizeDocumentation}, and being an interactive proof there is no way to verify the TLSNotary proof unless you were performing the role of the auditor during the retrieval. Oraclize, runs an auditor node on Amazon Web Services(AWS), claiming that this implementation is secure as far as AWS is trusted, simply moving trust to a bigger another central entity.

\section{SafetyNet}

\section{Android Proof}

\section{Ledger Proof}

\section{Promising proofs}

\subsection{TLS-N}

\subsection{Blockchain-based TLS notary service}

\section{Summary and conclusions}
