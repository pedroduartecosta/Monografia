\chapter{Validation} \label{chap:chap7}

\section*{}
In this Chapter, the author validates the proposed statements in the Chapter~\ref{chap:chap4} and to what extent they accomplish the proposed challenge.

Initially, the author compares the defined architectures with existing solutions and how broadly they describe all possible scenarios.

Then, the implemented solution in comparison to the state of the art, as well as its applicability, use case scenarios and limitations.


\section{Oracle Architectures}
In this section I will validate each architecture against the forces defined previous in the desiderata \ref{Desiderata}.


\subsection{Oracle as a Service w/ Single Data Feed}\label{OaaS w/SDF}
This architecture achieves a \textbf{fast time-to-market}, allowing the developer of the smart-contract to quickly retrieve data from the web by plugin-in a oracle-as-a-service solution. Thus, not requiring any study and development and maintenance of a oracle service, quickly satisfying the contract data needs.

In terms of \textbf{keeping trust standards}, this type of architectures usually involves the use of trusted hardware or authenticity proofs to achieve such end. There are some caveats associated with some of them, such as the most widely used one, TLSNotary, but others such has the Android Proof and the use of trusted hardware may suffice to guarantee trust in the oracle service if their implementation and proofs is readily and transparently available. This proofs are managed by the third-party provider and therefore are not an overhead in achieving a fast time-to-market.

\subsection{Oracle as a Service w/ Multiple Data Feeds}\label{OaaS w/ MDF}
Iterating on the previous architecture, this one upholds the same characteristics of the previous one, \textbf{fast time-to-market} and \textbf{keeping trust standards}.

However, in this scenario we don't fully trust the data-source. Trust here, has two components. Trusting the data-source availability (uptime) and trusting the veracity of the data provided. By querying multiple data-feeds and setting a quorum both problems are solved. If some data providers fail to answer the request and the minimum quorum upholds the contract can still perform its duties. And if we cannot trust a single party to provide the data, as doing so will give full power to the outcome of the contract to that single data provider, the problem is solved by having a minimum quorum that can provide the same answer. This way, any outlier in the selected data provider is discarded. Guaranteeing both \textbf{data-feed fault tolerance} and \textbf{data veracity}.

\subsection{Single-Party Self Hosted Oracle}\label{SP-SHO}
This scenario takes a different approach, from the two previous ones, in terms of where to place the trust. In the previous scenario, due to the use of a third-party, it is required that some sort of proof is generated in order to guarantee the good behaviour of the third party. However, this proofs do add an extra over head to each request in terms of memory and computation used. In a scenario where in which a set of predefined set of parties are stakeholders in the smart-contract execution, it is possible to skip the use of authenticity proofs by having all the parties contributing to the oracle execution. With such approach we get to \textbf{keep the trust standards} of the execution of the smart-contract as a whole.

However, this approach introduces increases the time-to-market as it requires to develop and maintain the oracle service.

Additionally, it reduces the costs of the oracle operation by removing the extra fee from each query. Also, as there is no need for authenticity proofs, the contract code becomes simpler and the storage costs decrease as well leading to \textbf{lower smart contract costs}. In fact, due to being purpose built, these contracts should have less executable code in comparison to contracts that need to fulfil a bigger list of requisites, \textbf{lower oracle complexity}, and therefore become cheaper contracts.

\subsection{Multi-Party Self Hosted Oracle}\label{MP-SHO}


\subsection{Conclusions}

\begin{table}[H]
    \centering
    \resizebox{\textwidth}{!}{%
        \begin{tabular}{@{}lcccc@{}}
                                       & \multicolumn{1}{l}{\begin{tabular}[c]{@{}l@{}}OaaS w/SDF \ref{OaaS w/SDF}\end{tabular}} & \multicolumn{1}{l}{\begin{tabular}[c]{@{}l@{}}OaaS w/MDF \ref{OaaS w/ MDF}\end{tabular}} & \multicolumn{1}{l}{\begin{tabular}[c]{@{}l@{}}SP-SHO \ref{SP-SHO}\end{tabular}} & \multicolumn{1}{l}{\begin{tabular}[c]{@{}l@{}}MP-SHO \ref{MP-SHO}\end{tabular}} \\ \midrule
            Fast time-to-market        & X                                             & X                                             &                                               &                                               \\ \midrule
            Keeping trust standards    & X*                                            &                X                              & X                                             & X                                             \\ \midrule
            Data-feed fault tolerance  &                                               & X                                             &                                               & X                                             \\ \midrule
            Data veracity              &                                               & X                                             &                                               & X                                             \\ \midrule
            Lower smart contract costs &                                               &                                               & X                                             & X                                             \\ \midrule
            Lower oracle complexity    &                                               &                                               & X                                             & X*                                            \\ \midrule
            Oracle decentralization    &                                               &                                               &                                               & X                                             \\ \midrule
            \begin{tabular}[c]{@{}l@{}}Oracle ownership \\ decentralization\end{tabular}  &                                               &                                               &                                               & X
        \end{tabular}%
    }
    \caption{Summary of architecture accomplishments? }
    \label{tab:architecture-summary}
\end{table}

\section{Self-hosted Oracle Implementation}
The author, proposes three main characteristics of its implementation comparing to the current existing oracle-as-a-service solutions. Reduced costs, higher trust and higher contract empowerment.


\subsection{Reduced costs}

In this context, cost per query compromises multiple dimensions. Firstly, the cost of querying the oracle and inputting the result in the contract which correspond to the execution of the contract code and is therefore directly related to the amount of code that needs to run. Secondly, underlying fees imposed by the third-party service. And finally, a cost of less importance relative to the former ones, the cost of the off-chain oracle service that will query the API.

Analysing the first one, the contract executing cost paid by the caller that is not much that the developer of the smart contract can do to optimize this cost since its fully managed by the third-party service. Hence, on a self-deployed oracle, cost can be further optimized by modelling a single purpose oracle for the smart contract needs which will inherently run less code due to its simplicity. Also, on a self-hosted oracle there is no need to add the over-head of authenticity proofs which either verified on chain or partially stored off-chain lead to higher transaction costs.

Secondly, existing services are for-profit companies and therefore require an extra-payment for their service. Oraclize.it adds an extra fee paid in dollars, depicted on table ~\ref{tab:oraclize-fees}, that depends on the datasource and authenticity proof used. Chainlink requires that every request is paid using its token LINK whose value depends on the current market price. In a self-deployed oracle approach none of this fees are present lowering therefore to lower costs.

\begin{table}
    \centering
    \begin{tabular}{@{}llllll@{}}
        \cmidrule(l){3-6}
                                       & \multicolumn{1}{l|}{}          & \multicolumn{4}{c|}{Proof type}                                                                                            \\ \cmidrule(r){1-2}
        \multicolumn{1}{c}{Datasource} & \multicolumn{1}{c}{Base price} & \multicolumn{1}{r}{None}        & \multicolumn{1}{r}{TLSNotary} & \multicolumn{1}{r}{Android} & \multicolumn{1}{r}{Ledger} \\ \midrule
        URL                            & 0.01\$                         & +0.0\$                          & +0.04\$                       & +0.04\$                     & N/A                        \\
        WolframAlpha                   & 0.03\$                         & +0.0\$                          & N/A                           & N/A                         & N/A                        \\
        IPFS                           & 0.01\$                         & +0.0\$                          & N/A                           & N/A                         & N/A                        \\
        random                         & 0.05\$                         & +0.0\$                          & N/A                           & N/A                         & +0.0\$                     \\
        computation                    & 0.50\$                         & +0.0\$                          & +0.04\$                       & +0.04\$                     & N/A                        \\ \bottomrule
    \end{tabular}
    \caption{Oraclize fees in USD}
    \label{tab:oraclize-fees}
\end{table}

Finally, in a self-deployed oracle scenario there are inherent costs of running the off-chain oracle which are taken care on a third-party service. Although the cost per transaction of the service depends on the platform in which the service will be deployed it can be assumed that in comparison to the fees or, even more, to the cost of executing the smart contract code this cost is risible. Solutions such as AWS Lambda~\footnote{https://aws.amazon.com/lambda/} that offer 1M requests and 400,000 GB-SECONDS of compute time per month for free in their free tier~\footnote{https://aws.amazon.com/lambda/pricing/ queried on the 29th of May 2019.}, and even in a scaling scenario each requests costs \$0.0000002. Therefore, this cost is not considered throughout this dissertation due to its small size in comparison with the previous analysed ones.

\subsection{Higher trust}

Trust is defined as having complete certainty that the provided answer is corrected or was indeed the one provided by the API. In the self-hosted oracle scenario both can be achieved. The first proposition, that the answer is correct, can be maximized by using multiple oracles and a quorum so that multiple sources can confirm the requested result. With minor alterations the oracle could receive more than one URL and maximize even more the trust in the result by querying multiple sources. The second, that the API actually return that value is achieved since the off-chain oracle is fully controlled by the parties interested in the result of the smart-contract and therefore know exactly the code being executed.

This approach, comparing to the state-of-the-art found solutions, although simple provides higher guarantees that the smart contract will receive the desired answer. In the current existing solutions, trust is ultimately achieved through the use of authenticity proofs, which, as analysed in Chapter~\ref{chap:chap3}, do not provide the necessary guarantees. Either by not being able to be analysed on the chain contract, and can only be later inspected. And also, their implementations can be dubious, has they are being managed by a third party and always require to trust in a higher entity such as the service where they are being deployed.

\subsection{Higher contract empowerment}

The presented implementation, provides a great starting point to be worked upon and tailored to a specific contract needs. At the moment, can already work with any JSON API and therefore be used in a wide range of applications. Being able to use and tailor, with minimum effort, the existing boiler plate and adapt to its needs. When using third-party services there's no such flexibility. Even in terms of which blockchain you can deploy the contract, some services are not yet available on some blockchains' mainnet, and features available are totally dependent on the oracle service provider.

\subsection{Conclusions}