\chapter{Problem Statement}\label{chap:chap4}

\section*{}

%% FIXME: Problem chapter
%O capítulo sobre o problema que devia aparecer neste ponto, precisa de conter:
% - descrição geral do problema (possivelmente repetindo um pouco, mas não inteiramente, do que foi dito no capítulo da introdução) e âmbito que pretendemos atacar
% - a hipótese central subjacente ao trabalho
% - as sub-hipóteses ou research questions mais concretas
% - qual a estratégia de investigação que será usada

Smart contracts power a decentralized world of automation and trust-less commitments. Companies, groups and individuals are able to automate tasks and contracts but in the current ecosystem, smart contracts are still very much limited to the information available in the blockchain. Therefore, connecting with the outside world requires a trusted authority to input in the blockchain the required information upon request from the smart contract. This trusted authority is generally called an oracle.

As explained before, the deterministic nature of blockchain does not allow smart contracts to directly query a data-feed for information. In this context, oracles help connecting smart contracts to the world outside of the blockchain. The problem here is to trust the oracle service to not behave maliciously and undermine the trust provided by the blockchain consensus mechanisms. Blockchain technology can be trusted to behave correctly even in byzantine environments, but the oracle service does not abide by the same rules and therefore some workings must be put into action to ensure the oracle's response credibility.

As seen in Chapter~\ref{chap:sota}, current solutions to the oracle problem use complex techniques to achieve a certain desired level of trust. Some use complicated trusted hardware others incentive-based mechanisms or authenticity proofs, but neither of these are simple and fully trusted approaches and they add extra complexity from the developer side.

The oracle problem is neither simple nor has a single solution, but its importance in powering greater applications for smart contracts  is undeniable. Their need arises from the following three factors.

%% acredito que ao fazer x tenho y beneficios

\begin{itemize}
    \item \textbf{Smart contract empowerment} - Providing smart contracts with trustable information from outside of the blockchain is decisive to gain general adoption and practicality.
    \item \textbf{Cost optimization} - Blockchain operations tend to be quite expensive, therefore, the oracle solution should introduce a lower overhead cost as possible.
    \item \textbf{Keeping trust standards} - As blockchain technology creates a trust-less environment, oracles should as well keep up with the level of trust in their functioning.
\end{itemize}

\section{Proposal}

With this thesis, the author intends to lay the foundations for the development and architecture of trustable oracle systems that will power several smart contract use cases.

The author believes that by describing, in a trust-guided manner, multiple patterns and examples where they are being applied or possible use cases not yet documented creates a guided model that helps future cases to have a systematic approach to which architecture will fit the best. The architecture and design of blockchain oracles is still very much unexplored territory, specially in terms of academia research but also in the industry, and therefore this thesis approaches it broadly and investigates possible approaches and their trade-offs so that later studies can be developed on the specifics of each architecture.

Furthermore, in Chapter \ref{chap:chap6}, the author presents a possible implementation of a self-hosted oracle. After analysing the state of the art in oracle development and the specifics of used authenticity proofs, the author believes that the best way to achieve trust in an oracle is to deploy one instead of relying on a third-party. The described approach, when in comparison to deployed solutions in the industry reduces operations costs, increases trust and empowers the contract with purpose built oracles. The author will demonstrate that deploying and oracle, can be more trivial than at first seems, and that trust in its operation is directly the trust in one's code and no more measures (authenticity proofs) are need. This measures usually add a considerable extra cost and constrain the developer.


\section{Desiderata}

This section describes the architectures that will be investigated. Some are already seen in oracle-as-a-service providers others not yet but can be explored in a self-hosted manner. They intend to open way to how oracles are developed and how they tackle different points of trust and scenarios.

To better discuss the purpose and usability of each architecture, the following subsections explain the use cases of each solution.


% FIXME: Change use cases name to be more specific to the problem

\subsection{Use Case 1: Oracle as a Service w/ Single Data Feed}

A smart contract developer needs to obtain information from an API source without having the trouble to develop and launch its on oracle whilst having some guarantees of the origin of the information. Mainly, this scenario is focusing on fast-time to market, untampered data and cost is not a problem.

\subsection{Use Case 2: Oracle as a Service w/ Multiple Data Feeds}

This scenario iterates on the previous one but focuses on data veracity. It can happen that the owner of the smart contract can not trust a single entity to provide the data. Either because he wants that no single entity can have a say on the final result of the contract or because the requested data may not have a discrete value and the best answer is the median of multiple values.

\subsection{Use Case 3: Single-Party Self Hosted Oracle}

This use case takes a different approach from the previous ones. Instead of fast-time to market the main focus here is trusting the oracle provider to behave correctly. The smart contract output will only affect a single party or multiple parties which are non competing and therefore trust someone to run the oracle. In such scenario, costs can be reduces, with increasing developer workload, by not using any authenticity proofs and the oracle can be further customised to handle a specific contract requirement.

\subsection{Use Case 4: Multi-Party Self Hosted Oracle}

Iterating on the previous use-case, this scenario adds a new trust problem. When competing parties deploy depend on the behaviour of the same smart contract. For example, in a bet, all parties want to have the same say in the final result as all of them have something to gain and to loose in the result inputed by the oracle. Therefore, some mechanism must ensure that several oracles and a predefined agreed quorum can be used to ensure that no party can cheat on the final result of the smart contract.

As this scenario, seems to be the least described in current literature but has the possibility of being applied to a plethora os use cases, for example betting contracts, logistic chains with competing companies and so on, an implementation is demonstrated on Chapter~\ref{chap:chap6}.


\section{Conclusions}
This project aims to pave the way for oracle and smart contract development. It does not try to come up with a new authenticity proof which adds extra complexity for the common smart contract developer, but instead guide the developer to a solution accordingly to the problem necessities. As well as, providing a simple but yet effective implementation of a self-hosted oracle so as to have a simple skeleton to which the developer can iterate upon and adapt to the specific smart contract needs.