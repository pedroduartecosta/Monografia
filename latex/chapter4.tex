\chapter{Authenticity Proofs}\label{chap:chap4}

\section*{}
As technology evolves and becomes mainstream so does the amount of generated data and its distribution. And so it becomes crucial to be able to authenticate a piece of information as originating from a known, trusted source. 

In the context of today's web we are accustomed to trust that a certain website or data is originated from the expected source due to the general adoption of the HTTPS protocol. An extension fo the HTTP protocol which creates and encrypted and authenticated channel between the client and the web-server providing the requested information. Then it becomes a matter of whether we trust the source or not, but not doubts are raised as for the channel through which we received it.

Unfortunately, in the context of blockchain, the most used, available and trusted protocols have not direct way of communicating with HTTPS enabled services and therefore obtain authenticated data. Creating a need for a trusted service, which if centralized if fallible unless it can provide an irrefutable proof of its honesty. 

Several authenticity mechanisms have therefore been developed and, as seen in the state-of-the-art revision, most oracles as a service providers use authenticity proofs to prove their honest behaviour. However, these proofs are not infallible and the details or their implementation are not always transparent or do not provide the disclosed level of trust. In this section, I will deep dive on the most common proofs and discuss their implementation and applicability.


\section{TLSNotary}

TLSNotary is a mechanism for independently audited HTTPS sessions. Allowing clients to provide evidence to a third party auditor that certain web traffic occurred between himself and the server. This mechanism takes leverage of the TLS handshake protocol to create a irrefutable proof as long as the auditor trusts the server's public key by splitting the TLS master key between three parties: the server, the auditee and the auditor.

The algorithm allows an auditor to verify some part of a session by withholding a small part of the secret data used to set up the HTTPS connection while allowing the client to conduct a HTTPS session normally. The auditor never fully possesses, at any time, any of the session keys and therefore cannot decrypt any sensitive information and can only verify that a certain traffic did occurred.

\subsection{How it works}
TLSNotary modifies the TLS handshake protocol on the client side by levering some properties of TLS 1.0 and 1.1. More specifically the pseudorandom function (PRF) used in the TLS 1.0 RFC 2246.

\begin{ceqn}
    \begin{align}
        PRF(secret,label,seed) = PMD5(S1,label+seed) \otimes PSHA-1(S2,label+seed)
    \end{align}
\end{ceqn}

This function compromises two secrets, S1 and S2. The auditor and auditee will independently generate S1 and S2, respectively. 

The auditee applies P\_MD5 to S1, generating 48 bytes:

\begin{ceqn}
    \begin{align}
        H_{1} = H_{1,1} \parallel H_{1,2}
    \end{align}
\end{ceqn}

The auditor applies P\_SHA-1 to S2, generating 48 bytes:

\begin{ceqn}
    \begin{align}
        H_{2} = H_{2,1} \parallel H_{2,2}
    \end{align}
\end{ceqn}


The auditor and auditee then exchange H21 and H12 allowing each other to construct different halves of the master secret, M2 and M1, respectively.

\begin{ceqn}
    \begin{align}
        M_{2} = H_{1,2} \parallel H_{2,2}
    \end{align}
\end{ceqn}

\begin{ceqn}
    \begin{align}
        M_{1} = H_{2,1} \parallel H_{1,1}
    \end{align}
\end{ceqn}

The auditee and auditor calculate X and Y, respectively.

\begin{ceqn}
    \begin{align}
        X = P\_MD5(M_{1})
    \end{align}
\end{ceqn}

\begin{ceqn}
    \begin{align}
        Y = P\_SHA-1(M_{2})
    \end{align}
\end{ceqn}

The auditor sends sufficient bytes from Y to the auditee so that it can compute the necessary encryption keys and client mac key to send the request to the server. 

Then the server response is received, but not decrypted, and the network traffic is logged and a hash is of the traffic is computed and set to the auditor as commitment. 

Only then, does the auditor send the remaining bytes of Y to the auditee that allow him to calculate the server mac key and safely execute a normal TLS decryption and authentication step.

These complex sequence of calculations prevent the auditee from creating a fake version of the post-handshake traffic from the server since he did not have in his possession the server mac write secret to decrypt and authenticate the initially requested data.

A more detailed flow and explanation can be consulted in the TLSNotary white-paper \cite{2014TLSnotary-aSessions}.

   
\subsection{Limitations}
TLSNotary, provides some capabilities to attest TLS connections but comes with several limitation. Firstly, TLSNotary supports only TLS 1.0 or 1.1, the properties mentioned before are not present in TLS 1.2 and 1.3 and former are considered less secure versions of TLS. Secondly, TLSNotary depends on RSA Key exchange, which does not provide forward secrecy. Thirdly, TLSNotary uses MD5 and SHA-1 functions, which are now considered deprecated. Finally and most importantly, TLSNotary requires trusting in a third party in most of its implementations, such as in Oraclize \cite{Oraclize.it2018OraclizeDocumentation}, and being an interactive proof there is no way to verify the TLSNotary proof unless you were performing the role of the auditor during the retrieval. Oraclize, runs an auditor node on Amazon Web Services(AWS), claiming that this implementation is secure as far as AWS is trusted, simply moving trust to a bigger another central entity. It also only allows the existence of one auditor in which we must trust, in a situation in which more than one auditor is required TLSNotary will not be able to satisfy such requirement.


\subsection{Conclusions}
The TLSNotary proof is promising due to be software based and is, as of this moment, the most spoken of authenticity proof. However, it's applicability is increasingly getting limited due to the deployment of new TLS versions and the assurances provided by the proof current implementations, which simply move the trust to a bigger entity. Therefore, it should not be considered a reliable authentication method for future implementations.

\section{Android Proof}
In the oracle context, the Android proof results from Oraclize research and development efforts. It takes leverage of SafetyNet software attestation and Android Hardware Attestation to provision a secure and auditable environment to fetch authenticated data. 

\subsection{SafetyNet Attestation}
SafetyNet, developed by Google, is an api service that allows to assess the Android device in which an app is running on. It provides a cryptographically-signed attestation, assessing the integrity of the device, looking at the software and hardware environment for integrity issues. By returning an SHA-256 hash of the application that called the SafeyNet API it allows to assess if the application running on the device has not been tampered with by comparing the application SHA-256 hash with its public available and distributed open-source code.

\subsection{Android Hardware Attestation}
Since Android Nougat, developers are able to generate and hardware attestation object with details regarding the device unique key stored in the Android Hardware KeyStore. The attestation object is signed by a special attestation key kept on the device and the root certificate regarding that key is a known Google certificate. This guarantees that the hardware running the code has not been tampered with.

\subsection{How it works}
The application running on the Android device, on its first run, creates a NIST-256p key pair, containing the Hardware Attestation Object to prove the integrity of the key, using the Android Hardware KeyStore and 

When a request is sent to the Android device, it starts an HTTPS connection and the entire HTTP response is retrieved. The response's SHA256 hash is signed using the hardware attested key pair created on the application start. A call to SafetyNet API is then used to attest the SHA-256 hash of the application package running on the device, which should be open-source and public available and distributed, guaranteeing the application integrity and therefore that not alteration has occurred on the HTTP response before it is signed and its hash used in the SafetyNet request.

SafetyNet then returns an attestation response in the JSON Web Signature format (JWS) that guarantees the integrity of the application running, the integrity of the system in which the application ran and that both the HTTPS request and signing process using the initially created and attested key have taken place in the application issuing the SafetyNet request.

The SafetyNet JWS response and the HTTP response is sent back for off-chain verification and validation.

\subsection{Conclusions}
The Android proof is a far more complex and in-depth authenticity proof in comparison to TLSNotary. It provides strong guarantees of software and hardware integrity as well as of the requested data. Nonetheless, it relies on a centralized authority, Google, to develop a secure Trusted Execution Environment (TEE), used by Android to generate private keys, and to maintain SafetyNet security sophisticated enough to offer good guarantees of the device and application integrity. A bottleneck in this approach can be the required use of a physical android device, limiting the scalability of this approach, but nonetheless, as long as Google is trustworthy it is a very secure model. 

\section{Ledger Proof}
The ledger proof is based on the use of a specific trusted environment, the Ledger Nano S and Ledger Blue, invented by a French company to secure crypto assets safely. This devices implement several layers of hardware and software to prove the security of its execution. These devices run a specific software, BOLOS, which has an SDK that enables developers to build application which can be installed on the hardware. BOLOS exposes a set of kernel-level API which allow running secure cryptographic operations as well as attest the device and the code running on it. The later is very useful as it allows to run code in a secure manner and provide an attestation for the code. An application can ask the kernel to produce a signed hash of the application binary code. A special attesting key is used in this process and is safely controlled by the kernel, away from attacks attempts by any application code. With this, the ledger proof leverages both the device attesting and code attesting features to prove that the applications are running on a TEE of a ledger device.

Currently the ledger proof is used by Oraclize to provide true random data to a smart contract. But is use can be extended to other computation operation that may required to be ran outside of the blockchain as long as supported in terms of computational and memory capacity by the ledger device. The device also lacks direct connection to the internet and therefore cannot be used to query data from the internet.

\section{Promising proofs}

\subsection{TLS-N}
TLS-N \cite{Ritzdorf2017}, is the first privacy preserving TLS extensions that is efficient and provides non-repudiation, not only in a single TLS message exchange but in a conversation compromising several messages. It allows, with an additional computation overhead, to obfuscate certain parts of the conversation (such as passwords or other sensitive information) while keeping it's trust model intact. TLS-N does not require the use of a third-party or any trusted hardware, it is an extension to the TLS 1.3 protocol, keeping it future proof (at least in a foresable future) comparing to other implentations such as TLSNotary which relie on deprecated versions.

\subsection{Blockchain-based TLS notary service}

\section{Summary and conclusions}
