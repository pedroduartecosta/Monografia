\chapter{Trustable Oracles }\label{chap:chap3}

\section*{}
%Este capítulo deve começar por fazer uma apresentação detalhada do
%problema a resolver\footnote{Na introdução a apresentação do
%  problema foi breve.} podendo mesmo, caso se justifique,
%constituir-se um capítulo com essa finalidade.

%Deve depois dedicar-se à apresentação da solução sem detalhes de
%implementação. 
%Dependendo do trabalho, pode ser uma descrição mais teórica, mais
%``arquitetural'', etc.


\section{Defining Trust}
  
At this point, a definition of what trust in a oracle is seems appropriate. Trust has a lot of meanings, depending on the needs of all the parties involved. I will model several levels of trust and the requirements and fallacies of each model as well as its application and drawbacks.

Starting from an absolute trust scenario, in this model, the end user, being the smart contract which receives information provided by the oracle, has complete assurances from both the veracity of the data provided by the data-source, as well as, undeniable proof that the oracle did not tamper with the relayed information. This scenario points out two main points of failure, either maliciously or unintentionally. 

The first component which can be faulty or compromised is the data-source. Assuring that the information provided is correct does not have a straightforward answer. What correct means is open to interpretation. For example, if the data source is an IoT sensor, which is prone to failures, being correct is relative. The sensor needs to be perfectly calibrated and accurate. In this case, using several sensors and averaging its values or removing outliers would solve its correctness. Another example, could be an API that returns the current value of the EUR in USD. In this scenario a party that would benefit from a higher conversion than the real one could coerce or attack the data-source into providing a favorable value. The answer here can also be using several data-sources. Another solution would be to use a highly trusted entity such as the European Central Bank (ECB) which can be a lot harder to coerce or attack and having a signatures from the ECB that backs the provided data. Choosing what type of data-source to use has a huge impact on the trust fullness of the provided data not to mention architecture centralization when using a source such as the ECB. All in all, the end user will have to understand the requirements and level of trust necessary.

The second, and most relevant for analysis, is the oracle service used. Oracles are a necessary part of the process, since the other option would be having the data providers adapting to the blockchain which does not seem to be a realistic option at the moment. Therefore we most trust an oracle or a group of oracles. Two main options are available, either trusting a third-party oracle or self deploying an oracle. In the first scenario, three variables take part in the level of trust. Firstly he third-party oracle, if paid for, has the monetary incentive to be honest, since a bad record of dishonesty would have the service loosing credibility and therefore clients. Secondly, by using proofs the oracle can establish its legitimacy, as long as, the proofs can undoubtedly be trusted and verifiable by the smart contract, I will later analyse in depth this issue. Finally, oracle execution transparency by using open-source code and having means for being audit. Additionally to guaranteeing single oracle integrity, it may be in the interest of the user to use several oracles either to provide service availability or to increase trust by combining the result from different oracle services.


\section{Oracle Architectures}

\subsection{Oracle as a Service w/ Single Data Feed.}

\subsubsection{Context}
Smart contracts will provably power a decentralized world of automation and trust-less commitments. Companies, groups and individuals will be able to automate tasks and contracts but as far as the ecosystem is, at the moment, smart contracts are limited to the information available in the blockchain. Therefore, connecting with the outside world requires a trusted authority to input in the blockchain the required information upon request from the smart contract. This trusted authority is generally called an oracle. 

\subsubsection{Example}



\subsubsection{Problem}
As explained before, the deterministic nature of blockchain does not allow smart contracts to directly query a data-feed for information. In this context, oracles surge to empower business and smart contract capabilities, connecting smart contracts to the world outside of the blockchain. The problem here is to trust in the oracle service to not behave maliciously and undermine the trust provided by the blockchain consensus mechanisms. Blockchain technology can be trusted to behave correctly even in byzantine environments, but the oracle service does not abide by the same mechanisms and therefore must provide some kind of proof of honesty.

\subsubsection{Forces}
\begin{itemize}
\item \textbf{Smart contract empowerment} - Providing smart contracts with trustable information from outside of the blockchain is decisive to gain general adoption and practicality.
\item \textbf{Blockchain Interoperability} - The ability to get information from other blockchains if possible using an oracle that queries one blockchain and inputs the information on another.
\item \textbf{Keeping trust standards} - As blockchain technology creates a trust-less environment, oracles should as well keep up with the level of trust in their functioning.
\end{itemize}


\subsubsection{Solution}
A solution is to use a secure authenticated channel between any external data-source and blockchain applications, known as Oracle. A proposed and existing solution in the market is Oraclize  \cite{Oraclize.it2018OraclizeDocumentation}. Currently providing fee-based oracles in which smart contracts pay for each request. In order to achieve a higher level of trust, for an extra fee, it can also provide proofs that the provided data as not been tampered by their oracle. The extent to which this proofs can be trusted will be further analysed. 

\begin{figure*}[t]
  \begin{center}
    \leavevmode
    \includegraphics[width=0.5\textwidth]{figures/oraclearch1.jpg}
    \caption{Oracle as a Service w/ Single Data Feed.}
    \label{fig:/figures/paper-screening}
  \end{center}
\end{figure*}

\subsubsection{Example Resolved}


\subsubsection{Resulting Context}
This solution results in an architecture that compromises two points of trust. The first being the data-feed itself. No guarantees are given that the data provided is reliable and the smart contract owner must therefore, to the best of his knowledge, select a data-feed in which, by the operator size or record of good behavior, he can trust.

The second point of failure is the oracle service itself. Although smart contracts, in the resulting context, have access to the information from the outside, that is only possible due to the use of a third party to honestly relay the data. In this architecture, if the oracle simply relays the data, then no trust model can be achieved as the oracle good behavior is not tested against. As this would not be a feasible architecture the existing services provide authenticity proofs to guarantee, to a certain level, their honest behavior. The problem here is on how are these proofs generated, can they be verified on-chain or only off-chain and who is making, or providing, the verification tools. In chapter 4 I deep dive on these questions and techniques. Another reason to trust in the service can be the monetary incentive for good behavior. By paying the oracle for each request, that becomes the oracle service business model and therefore an extensive record of good behavior if crucial for business prosperity and therefore a good enough incentive for honestly conveying the requested data.
In this context, if the authenticity proofs provide enough assurances for the smart contract creator and he trustees in the selected data-feed to provide the required data, then this model can satisfy its needs in terms of trust, as well as, performance, since it only queries one data-feed and uses only one oracle. By not having any consensus mechanism an exchanging the least amount of messages it can both achieve greater performance and a lower cost. But this lower cost and higher performance architecture by itself  is prone to failure due to lack of decentralization and does not guarantee service availability which could lead to a failure in the smart contract to obtain the requested information.



\subsubsection{Known Uses}


\subsection{Oracle as a Service w/ Multiple Data Feeds.}

\subsubsection{Context}
Sometimes an answer to a contract request cannot be truly accepted unless several sources confirm it. Either because it is unwise to trust in a single identity or because there might not be a single true answer but only an answer that is accepted by a selected majority.

\subsubsection{Example} 

\subsubsection{Problem}
The previous architecture specified a single point of failure on the data-source layer. A contract with high requirements in terms of availability cannot rely on using a single data-source, as doing so would void the contract when the service providing that data is down or taken down. In terms of trust, certain contracts may also require that several services provide an answer and then have a consensus between all the received answers. This cannot be achieved by querying a single source and therefore the oracle service must be able to query several sources and either define the resulting answer or provide all the responses to the smart contract and let the smart contract resolve to a final answer.

\subsubsection{Forces}
\begin{itemize}
\item \textbf{Data-feed fault tolerance} - Ensuring that a contract can follow through even if a data provider is down by querying another provider.
\item \textbf{Trusting data} - By querying several data sources there is a higher trust on the veracity of the data.
\end{itemize}

\subsubsection{Solution}
\begin{figure*}[t]
  \begin{center}
    \leavevmode
    \includegraphics[width=0.5\textwidth]{figures/oraclearch2.jpg}
    \caption{Oracle as a Service w/ Multiple Data Feeds.}
    \label{fig:/figures/paper-screening}
  \end{center}
\end{figure*}

\subsubsection{Example Resolved}
\subsubsection{Resulting Context}
In this context, the layer of trust regarding the data-feed is almost eliminated by having the ability to choose from several data providers and therefore not relying on a source of truth. It also provides a higher system availability, as the oracle/smart contract can have some degree of redundancy in the data providers selection.

\subsubsection{Known Uses}

\subsection{Single-Party Self Hosted Oracle.}

\subsubsection{Context}
Although the use of Oracles as a Service allows for a low product time to market by not having to take care of the development, maintenance and deployment of the oracle service it usually leads to less flexibility in the oracle design, vendor lock-in and fees charged by the vendor. If the product requirements do not allow for the specified challenges or the trust levels required by the contract are more than what the oracle vendor can provide it may be a solution to deploy its own oracle. A company with its own developing team capable of allocating resources for the development of the oracle or a single developer who does not want to incur in the oracle vendor fees will benefit from their own deployment in terms of cost and most importantly in regard to trusting the oracle behavior.

\subsubsection{Example}


\subsubsection{Problem}
Currently, oracle behavior is neither easy to check nor fully transparent and trustable. As seen in chapter \ref{chap:chap4}, verifying oracles authenticity proofs sometimes cannot be done on-chain, resulting in a contract being executed with an incorrect proof which is only later verified but the contract is irreversible adding not much to oracle trustability except the ability to cancel future contracts. Proofs also add complexity to the smart contract code which will result in slower contract development and more importantly in higher contract costs. Most blockchains charge contracts by either CPU, memory and network use, or even all of these, and therefore receiving the proof and verifying it on chain will increase the cost of running a contract. 

\subsubsection{Forces}
\begin{itemize}
  \item \textbf{Higher trust on oracle behavior} - Oracle good behavior is usually backed by authenticity proofs which are expensive to check on chain or don't bring much value to the contract when verified off-chain since the current contract already executed its code with tampered data.
  \item \textbf{Lower smart contract costs} - Checking authenticity proofs leads to higher contract deployment costs, as the proof can be long and computational expensive.
  \item \textbf{Lower smart contract complexity} - Verifying authenticity proofs on chain requires the developer to have sufficient knowledge to write the verifying functions. 
\end{itemize}

\subsubsection{Solution}
A solution to trusting a oracle service is to deploy our own oracle service. Surely, doing so incurs in technical expenses for programming, deploying and maintaining the oracle, however does not require to trust in a third party but only on our ability to maintain the necessary level of security in our own oracle. Additionally, it will free the smart contract owner from the fees charged by the oracle provider and allow for further flexibility in adapting the oracle to new sources of information. Furthermore, it will also lead to simpler and cheaper smart contracts by not requiring the use of authenticity proofs in regards to the oracle behavior, as the developer knows exactly what the oracle is running under the hood.

\begin{figure*}[t]
  \begin{center}
    \leavevmode
    \includegraphics[width=0.5\textwidth]{figures/oraclearch3.jpg}
    \caption{Single-Party Self Hosted Oracle.}
    \label{fig:/figures/paper-screening}
  \end{center}
\end{figure*}


\subsubsection{Example Resolved}
\subsubsection{Resulting Context}
With this solution we almost remove the second layer of trust, trusting in the oracle service. Nonetheless, we move the trust to the developer ability in coding a secure and reliable oracle. The main benefit is not requiring to have the overhead expense of using, understanding and verifying the authenticity proofs required for a trustable use of Oracles as a service. 

\subsubsection{Known Uses}

\subsection{Multi-Party Self Hosted Oracle.}

\subsubsection{Context}
In some cases, competing parties may rely on a smart contract to keep track of some value with interest to them, therefore, it may be a requirement that several of these parties take part in the process of providing the data to the smart contract. It may also be the case, that if a single oracle is the source of truth of a smart contract, then the easiest way to attack the smart contract is by attacking the central point of failure, the oracle. In both of theses cases the oracle singularity needs to be tackled.

\subsubsection{Example}

\subsubsection{Problem}
This context raises two problems, oracle consensus and availability. Whoever owns the oracle providing the data to the smart contract holds the smart contract and therefore can influence the execution of the contract, in which several competing parties rely. In terms of availability, a single oracle creates a single point of failure in case of an attack or system failure.

\subsubsection{Forces}
\begin{itemize}
  \item \textbf{Oracle decentralization} - connecting a smart contract to data through a single node, creates the problem that smart contracts intend to avoid, a single point of failure. With a single oracle, a smart contract is only as reliable as that one oracle.
  \item \textbf{Oracle ownership decentralization} - having one party control the oracle network centralizes the power to manipulate all the contracts relying on the information provided by that network of oracles.
\end{itemize}

\subsubsection{Solution}
The most beneficial and simple solution, here, is having each interested party launching their own oracle and having all oracles communicating between themselves with a mechanism for consensus. The consensus mechanism would vary from case to case, and from how critical the smart contract solution is.
To increase the level of trust in each party, each node would sign their response and be able to launch only one node. With this, once one of the nodes had collected all the signatures than it would provide the contract with the requested information. Also, a party would not be able to gain control over the network of oracles by launching more nodes than the remaining stakeholders.
However, the consensus algorithm should never require that all nodes provide a response since that would again create a weak network in which by tacking down one oracle the whole system would fail.


\begin{figure*}[t]
  \begin{center}
    \leavevmode
    \includegraphics[width=0.5\textwidth]{figures/oraclearch4.jpg}
    \caption{Multi-Party Self Hosted Oracle.}
    \label{fig:/figures/paper-screening}
  \end{center}
\end{figure*}

\subsubsection{Example Resolved}
\subsubsection{Resulting Context}
With this context, we bring the same trust level given by blockchain technology to the oracle service. Resulting in a decentralized network with no single party running it and every stakeholder having the same weight in providing the data. This context, however, is only suitable for previously defined user groups, with and agreed minimum necessary quorum for consensus and known public keys of all nodes.

In a community context, this approach is not suitable since nodes would be able to join and leave making it harder to achieve a predefined consensus. Involved parties would be able to launch more than one node, resulting in some parties being able to take over the minimum consensus quorum and overpower the network, unless some proof-of-work mechanism is implemented. This would also result in a context of wisdom of the crowd, in which the most effective way of controlling a correct answer would be by implementing some incentives mechanism such as \cite{AdlerAstraea:Oracle}. The problem around incentives is that they do not guarantee that, in edge cases, with enough incentives the network will provide a wrong answer if justifiable. Although, as far as the author is concerned, no other mechanism is available when dealing with wisdom of the crowd information. // Talvez valha a pena continuar esta parte numa nova architectura em que por ventura se use crowd em conjunto com provas criptograficas.

\subsubsection{Known Uses}


\section{Summary and conclusions}
